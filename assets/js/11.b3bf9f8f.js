(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{256:function(t,a,s){"use strict";s.r(a);var r=s(28),_=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("排序算法非常的多，如下图所示。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://lyneee-blog-1251928147.cos.ap-chengdu.myqcloud.com/blog/2020041518Dl5Q2m.png",alt:"排序算法"}})]),t._v(" "),s("p",[t._v("可以分为三类，基于时间复杂度。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://lyneee-blog-1251928147.cos.ap-chengdu.myqcloud.com/blog/2020041518image-20200415181942126.png",alt:"三种排序算法"}})]),t._v(" "),s("h2",{attrs:{id:"如何分析一个排序算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何分析一个排序算法"}},[t._v("#")]),t._v(" 如何分析一个排序算法")]),t._v(" "),s("h3",{attrs:{id:"算法的执行效率"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#算法的执行效率"}},[t._v("#")]),t._v(" 算法的执行效率")]),t._v(" "),s("h4",{attrs:{id:"_1-最好情况，最坏情况，平均时间复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-最好情况，最坏情况，平均时间复杂度"}},[t._v("#")]),t._v(" 1. 最好情况，最坏情况，平均时间复杂度")]),t._v(" "),s("p",[t._v("为什么要区分这三种时间复杂度呢？")]),t._v(" "),s("p",[t._v("第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。")]),t._v(" "),s("p",[t._v("第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。")]),t._v(" "),s("h4",{attrs:{id:"_2-时间复杂度的系数、常数、低阶"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-时间复杂度的系数、常数、低阶"}},[t._v("#")]),t._v(" 2. 时间复杂度的系数、常数、低阶")]),t._v(" "),s("p",[t._v("实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。")]),t._v(" "),s("h4",{attrs:{id:"_3-比较次数和交换移动的次数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-比较次数和交换移动的次数"}},[t._v("#")]),t._v(" 3. 比较次数和交换移动的次数")]),t._v(" "),s("p",[t._v("基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。")]),t._v(" "),s("h3",{attrs:{id:"排序算法的内存消耗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#排序算法的内存消耗"}},[t._v("#")]),t._v(" 排序算法的内存消耗")]),t._v(" "),s("p",[t._v("排序算法的内存消耗可以通过空间复杂度来进行衡量，对于排序算法，有一个新的概念叫"),s("strong",[t._v("原地排序：（Sorted in place)")]),t._v("，特指的是空间复杂度为O(1)的排序算法。")]),t._v(" "),s("h3",{attrs:{id:"排序算法的稳定性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#排序算法的稳定性"}},[t._v("#")]),t._v(" 排序算法的稳定性")]),t._v(" "),s("p",[s("strong",[t._v("稳定性")]),t._v("：这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。")])])}),[],!1,null,null,null);a.default=_.exports}}]);
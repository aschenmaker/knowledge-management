(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{265:function(t,a,s){"use strict";s.r(a);var r=s(28),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[s("strong",[t._v("如何实现一个通用的、高性能的排序函数？")])]),t._v(" "),s("h2",{attrs:{id:"如何选择合适的排序算法？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何选择合适的排序算法？"}},[t._v("#")]),t._v(" 如何选择合适的排序算法？")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://lyneee-blog-1251928147.cos.ap-chengdu.myqcloud.com/blog/2020041814tQqjnj.jpg",alt:"排序算法"}})]),t._v(" "),s("h3",{attrs:{id:"如何优化快速排序："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何优化快速排序："}},[t._v("#")]),t._v(" 如何优化快速排序：")]),t._v(" "),s("p",[t._v("如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为 O(n2)。实际上，这种 O(n2) 时间复杂度出现的主要原因还是因为我们分区点选的不够合理。")]),t._v(" "),s("h4",{attrs:{id:"_1-三数取中法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-三数取中法"}},[t._v("#")]),t._v(" 1.三数取中法")]),t._v(" "),s("p",[t._v("我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。")]),t._v(" "),s("h4",{attrs:{id:"_2-随机法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-随机法"}},[t._v("#")]),t._v(" 2.随机法")]),t._v(" "),s("p",[t._v("随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选的很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n2) 的情况，出现的可能性不大。")])])}),[],!1,null,null,null);a.default=e.exports}}]);